
/private/var/folders/vm/bdt9x53j7v16kbkysh__z1p00000gn/T/arduino/sketches/2450BE357B00CBD5592D5A3E5D7C44AB/011_MegaTiny_Neopixel.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../../crt1/gcrt1.S:63
   0:	1b c0       	rjmp	.+54     	; 0x38 <__dtors_end>
../../../../../crt1/gcrt1.S:67
   2:	4b c0       	rjmp	.+150    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:68
   4:	4a c0       	rjmp	.+148    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:69
   6:	49 c0       	rjmp	.+146    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:70
   8:	48 c0       	rjmp	.+144    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:71
   a:	47 c0       	rjmp	.+142    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:72
   c:	46 c0       	rjmp	.+140    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:73
   e:	45 c0       	rjmp	.+138    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:74
  10:	44 c0       	rjmp	.+136    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:75
  12:	43 c0       	rjmp	.+134    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:76
  14:	42 c0       	rjmp	.+132    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:77
  16:	41 c0       	rjmp	.+130    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:78
  18:	40 c0       	rjmp	.+128    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:79
  1a:	3f c0       	rjmp	.+126    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:80
  1c:	de c1       	rjmp	.+956    	; 0x3da <__vector_14>
../../../../../crt1/gcrt1.S:81
  1e:	3d c0       	rjmp	.+122    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:82
  20:	3c c0       	rjmp	.+120    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:83
  22:	3b c0       	rjmp	.+118    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:84
  24:	3a c0       	rjmp	.+116    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:85
  26:	39 c0       	rjmp	.+114    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:86
  28:	38 c0       	rjmp	.+112    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:87
  2a:	37 c0       	rjmp	.+110    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:88
  2c:	36 c0       	rjmp	.+108    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:89
  2e:	35 c0       	rjmp	.+106    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:90
  30:	34 c0       	rjmp	.+104    	; 0x9a <__bad_interrupt>
../../../../../crt1/gcrt1.S:91
  32:	33 c0       	rjmp	.+102    	; 0x9a <__bad_interrupt>

00000034 <__ctors_start>:
__trampolines_start():
  34:	da 02       	muls	r29, r26

00000036 <__ctors_end>:
__dtors_start():
  36:	e6 02       	muls	r30, r22

00000038 <__dtors_end>:
__dtors_end():
../../../../../crt1/gcrt1.S:230
  38:	11 24       	eor	r1, r1
../../../../../crt1/gcrt1.S:231
  3a:	1f be       	out	0x3f, r1	; 63
../../../../../crt1/gcrt1.S:232
  3c:	cf ef       	ldi	r28, 0xFF	; 255
../../../../../crt1/gcrt1.S:234
  3e:	cd bf       	out	0x3d, r28	; 61
../../../../../crt1/gcrt1.S:236
  40:	df e3       	ldi	r29, 0x3F	; 63
../../../../../crt1/gcrt1.S:237
  42:	de bf       	out	0x3e, r29	; 62

00000044 <_initThreeStuff()>:
_Z15_initThreeStuffv():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  44:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <digital_pin_to_bit_mask+0x7f778e>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
  48:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <digital_pin_to_bit_mask+0x7f778e>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:106
    if (flags == 0) {
  4c:	81 11       	cpse	r24, r1
  4e:	05 c0       	rjmp	.+10     	; 0x5a <_initThreeStuff()+0x16>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  50:	98 ed       	ldi	r25, 0xD8	; 216
  52:	21 e0       	ldi	r18, 0x01	; 1
  54:	94 bf       	out	0x34, r25	; 52
  56:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <digital_pin_to_bit_mask+0x7f778f>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
  5a:	8c bb       	out	0x1c, r24	; 28

0000005c <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  5c:	2f e3       	ldi	r18, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  5e:	a6 e0       	ldi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  60:	bf e3       	ldi	r27, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  62:	01 c0       	rjmp	.+2      	; 0x66 <.do_clear_bss_start>

00000064 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  64:	1d 92       	st	X+, r1

00000066 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  66:	a0 34       	cpi	r26, 0x40	; 64
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  68:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  6a:	e1 f7       	brne	.-8      	; 0x64 <.do_clear_bss_loop>

0000006c <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  6c:	1f e3       	ldi	r17, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  6e:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  70:	bf e3       	ldi	r27, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  72:	e8 eb       	ldi	r30, 0xB8	; 184
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  74:	f8 e0       	ldi	r31, 0x08	; 8
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  76:	02 c0       	rjmp	.+4      	; 0x7c <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  78:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  7a:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  7c:	a6 30       	cpi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  7e:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  80:	d9 f7       	brne	.-10     	; 0x78 <__do_copy_data+0xc>

00000082 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  82:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  84:	cb e1       	ldi	r28, 0x1B	; 27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  86:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  88:	03 c0       	rjmp	.+6      	; 0x90 <__do_global_ctors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  8a:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  8c:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  8e:	be d2       	rcall	.+1404   	; 0x60c <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  90:	ca 31       	cpi	r28, 0x1A	; 26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  92:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  94:	d1 f7       	brne	.-12     	; 0x8a <__do_global_ctors+0x8>
../../../../../crt1/gcrt1.S:314
  96:	29 d2       	rcall	.+1106   	; 0x4ea <main>
../../../../../crt1/gcrt1.S:315
  98:	f7 c3       	rjmp	.+2030   	; 0x888 <__do_global_dtors>

0000009a <__bad_interrupt>:
__vector_22():
../../../../../crt1/gcrt1.S:209
  9a:	b2 cf       	rjmp	.-156    	; 0x0 <__vectors>

0000009c <delay.part.0.constprop.1>:
delay.part.0.constprop.1():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:441
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
  9c:	8f b7       	in	r24, 0x3f	; 63
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:442
    cli();
  9e:	f8 94       	cli
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:493
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
  a0:	40 91 36 3f 	lds	r20, 0x3F36	; 0x803f36 <timingStruct+0x4>
  a4:	50 91 37 3f 	lds	r21, 0x3F37	; 0x803f37 <timingStruct+0x5>
  a8:	60 91 38 3f 	lds	r22, 0x3F38	; 0x803f38 <timingStruct+0x6>
  ac:	70 91 39 3f 	lds	r23, 0x3F39	; 0x803f39 <timingStruct+0x7>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:494
      SREG = oldSREG;
  b0:	8f bf       	out	0x3f, r24	; 63
millis():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:441
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
  b2:	2f b7       	in	r18, 0x3f	; 63
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:442
    cli();
  b4:	f8 94       	cli
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:493
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
  b6:	80 91 36 3f 	lds	r24, 0x3F36	; 0x803f36 <timingStruct+0x4>
  ba:	90 91 37 3f 	lds	r25, 0x3F37	; 0x803f37 <timingStruct+0x5>
  be:	a0 91 38 3f 	lds	r26, 0x3F38	; 0x803f38 <timingStruct+0x6>
  c2:	b0 91 39 3f 	lds	r27, 0x3F39	; 0x803f39 <timingStruct+0x7>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:494
      SREG = oldSREG;
  c6:	2f bf       	out	0x3f, r18	; 63
delay.part.0.constprop.1():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:980
      while(ms--) {
        _delay_ms(1);
      }
    } else {
      uint32_t start = millis();
      while (millis() - start < ms);
  c8:	84 1b       	sub	r24, r20
  ca:	95 0b       	sbc	r25, r21
  cc:	a6 0b       	sbc	r26, r22
  ce:	b7 0b       	sbc	r27, r23
  d0:	88 3e       	cpi	r24, 0xE8	; 232
  d2:	93 40       	sbci	r25, 0x03	; 3
  d4:	a1 05       	cpc	r26, r1
  d6:	b1 05       	cpc	r27, r1
  d8:	60 f3       	brcs	.-40     	; 0xb2 <delay.part.0.constprop.1+0x16>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:982
    }
  }
  da:	08 95       	ret

000000dc <micros>:
micros():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:508
    #else /* TCA */
      uint8_t ticks;
    #endif
    uint8_t flags;
    /* Save current state and disable interrupts */
    uint8_t oldSREG = SREG;
  dc:	9f b7       	in	r25, 0x3f	; 63
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:509
    cli(); /* INTERRUPTS OFF */
  de:	f8 94       	cli
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:514
    #if defined(MILLIS_USE_TIMERA0)
      ticks = TCA0.SPLIT.HCNT;
      flags = TCA0.SPLIT.INTFLAGS;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CTRLE = TCD_SCAPTUREA_bm;
  e0:	88 e0       	ldi	r24, 0x08	; 8
  e2:	80 93 84 0a 	sts	0x0A84, r24	; 0x800a84 <digital_pin_to_bit_mask+0x7f81d2>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:515
      while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
  e6:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <digital_pin_to_bit_mask+0x7f81dc>
  ea:	81 ff       	sbrs	r24, 1
  ec:	fc cf       	rjmp	.-8      	; 0xe6 <micros+0xa>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:516
      flags = TCD0.INTFLAGS;
  ee:	80 91 8d 0a 	lds	r24, 0x0A8D	; 0x800a8d <digital_pin_to_bit_mask+0x7f81db>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:517
      ticks = TCD0.CAPTUREA;
  f2:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <digital_pin_to_bit_mask+0x7f81f0>
  f6:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <digital_pin_to_bit_mask+0x7f81f1>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:528
     * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
     * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
     * doesn't matter.
     * Get current number of overflows and timer count */
    #if !((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)))
      overflows = timingStruct.timer_overflow_count;
  fa:	20 91 32 3f 	lds	r18, 0x3F32	; 0x803f32 <timingStruct>
  fe:	30 91 33 3f 	lds	r19, 0x3F33	; 0x803f33 <timingStruct+0x1>
 102:	40 91 34 3f 	lds	r20, 0x3F34	; 0x803f34 <timingStruct+0x2>
 106:	50 91 35 3f 	lds	r21, 0x3F35	; 0x803f35 <timingStruct+0x3>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:533
    #else
      overflows = timingStruct.timer_millis;
    #endif
    /* Turn interrupts back on, assuming they were on when micros was called. */
    SREG = oldSREG; /* INTERRUPTS ON */
 10a:	9f bf       	out	0x3f, r25	; 63
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:535
    #if defined(MILLIS_USE_TIMERD0)
      if ((flags & TCD_OVF_bm) && (ticks < 0x07)) {
 10c:	80 ff       	sbrs	r24, 0
 10e:	07 c0       	rjmp	.+14     	; 0x11e <__DATA_REGION_LENGTH__+0x1e>
 110:	e7 30       	cpi	r30, 0x07	; 7
 112:	f1 05       	cpc	r31, r1
 114:	20 f4       	brcc	.+8      	; 0x11e <__DATA_REGION_LENGTH__+0x1e>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:545
      if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
    #endif
    #if ((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) && !(F_CPU > 2000000UL))
      overflows +=2;
    #else
      overflows++;
 116:	2f 5f       	subi	r18, 0xFF	; 255
 118:	3f 4f       	sbci	r19, 0xFF	; 255
 11a:	4f 4f       	sbci	r20, 0xFF	; 255
 11c:	5f 4f       	sbci	r21, 0xFF	; 255
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:551
    #endif
      } // end getting ticks

    #if defined(MILLIS_USE_TIMERD0)
      #if (F_CPU == 20000000UL || F_CPU == 10000000UL || F_CPU == 5000000UL)
        uint8_t ticks_l = ticks >> 1;
 11e:	bf 01       	movw	r22, r30
 120:	76 95       	lsr	r23
 122:	67 95       	ror	r22
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:552
        ticks = ticks + ticks_l + ((ticks_l >> 2) - (ticks_l >> 4) + (ticks_l >> 7));
 124:	cf 01       	movw	r24, r30
 126:	86 0f       	add	r24, r22
 128:	91 1d       	adc	r25, r1
 12a:	e6 2f       	mov	r30, r22
 12c:	e6 95       	lsr	r30
 12e:	e6 95       	lsr	r30
 130:	76 2f       	mov	r23, r22
 132:	72 95       	swap	r23
 134:	7f 70       	andi	r23, 0x0F	; 15
 136:	e7 1b       	sub	r30, r23
 138:	ff 0b       	sbc	r31, r31
 13a:	67 fd       	sbrc	r22, 7
 13c:	31 96       	adiw	r30, 0x01	; 1
 13e:	e8 0f       	add	r30, r24
 140:	f9 1f       	adc	r31, r25
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:555
        // + ticks +(ticks>>1)+(ticks>>3)-(ticks>>5)+(ticks>>8))
        // speed optimization via doing math with smaller datatypes, since we know high byte is 1 or 0.
        microseconds =   overflows * (TIME_TRACKING_CYCLES_PER_OVF / 20) + ticks; // ticks value corrected above.
 142:	a0 e3       	ldi	r26, 0x30	; 48
 144:	b3 e0       	ldi	r27, 0x03	; 3
 146:	58 d2       	rcall	.+1200   	; 0x5f8 <__muluhisi3>
 148:	6e 0f       	add	r22, r30
 14a:	7f 1f       	adc	r23, r31
 14c:	81 1d       	adc	r24, r1
 14e:	91 1d       	adc	r25, r1
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:893
        microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                      + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
      #endif
    #endif // end of timer-specific part of micros calculations
    return microseconds;
  }
 150:	08 95       	ret

00000152 <tinyNeoPixel::setPixelColor(unsigned int, unsigned char, unsigned char, unsigned char) [clone .part.1]>:
_ZN12tinyNeoPixel13setPixelColorEjhhh.part.1():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1141
  port    = portOutputRegister(digitalPinToPort(p));
  pinMask = digitalPinToBitMask(p);
}

// Set pixel color from separate R,G,B components:
void tinyNeoPixel::setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 152:	0f 93       	push	r16
 154:	1f 93       	push	r17
 156:	dc 01       	movw	r26, r24
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1143
  if (n < numLEDs) {
    if (brightness) { // See notes in setBrightness()
 158:	18 96       	adiw	r26, 0x08	; 8
 15a:	8c 91       	ld	r24, X
 15c:	18 97       	sbiw	r26, 0x08	; 8
 15e:	88 23       	and	r24, r24
 160:	61 f0       	breq	.+24     	; 0x17a <tinyNeoPixel::setPixelColor(unsigned int, unsigned char, unsigned char, unsigned char) [clone .part.1]+0x28>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1144
      r = (r * brightness) >> 8;
 162:	48 9f       	mul	r20, r24
 164:	a0 01       	movw	r20, r0
 166:	11 24       	eor	r1, r1
 168:	45 2f       	mov	r20, r21
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1145
      g = (g * brightness) >> 8;
 16a:	82 9f       	mul	r24, r18
 16c:	90 01       	movw	r18, r0
 16e:	11 24       	eor	r1, r1
 170:	23 2f       	mov	r18, r19
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1146
      b = (b * brightness) >> 8;
 172:	80 9f       	mul	r24, r16
 174:	80 01       	movw	r16, r0
 176:	11 24       	eor	r1, r1
 178:	01 2f       	mov	r16, r17
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1149
    }
    uint8_t *p;
    if (wOffset == rOffset) { // Is an RGB-type strip
 17a:	1e 96       	adiw	r26, 0x0e	; 14
 17c:	8c 91       	ld	r24, X
 17e:	1e 97       	sbiw	r26, 0x0e	; 14
 180:	19 96       	adiw	r26, 0x09	; 9
 182:	ed 91       	ld	r30, X+
 184:	fc 91       	ld	r31, X
 186:	1a 97       	sbiw	r26, 0x0a	; 10
 188:	1b 96       	adiw	r26, 0x0b	; 11
 18a:	9c 91       	ld	r25, X
 18c:	1b 97       	sbiw	r26, 0x0b	; 11
 18e:	89 13       	cpse	r24, r25
 190:	1e c0       	rjmp	.+60     	; 0x1ce <tinyNeoPixel::setPixelColor(unsigned int, unsigned char, unsigned char, unsigned char) [clone .part.1]+0x7c>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1150
      p = &pixels[n * 3];    // 3 bytes per pixel
 192:	cb 01       	movw	r24, r22
 194:	88 0f       	add	r24, r24
 196:	99 1f       	adc	r25, r25
 198:	68 0f       	add	r22, r24
 19a:	79 1f       	adc	r23, r25
 19c:	6e 0f       	add	r22, r30
 19e:	7f 1f       	adc	r23, r31
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1155
    } else {                 // Is a WRGB-type strip
      p = &pixels[n * 4];    // 4 bytes per pixel
      p[wOffset] = 0;        // But only R,G,B passed -- set W to 0
    }
    p[rOffset] = r;          // R,G,B always stored
 1a0:	1b 96       	adiw	r26, 0x0b	; 11
 1a2:	ec 91       	ld	r30, X
 1a4:	1b 97       	sbiw	r26, 0x0b	; 11
 1a6:	e6 0f       	add	r30, r22
 1a8:	f7 2f       	mov	r31, r23
 1aa:	f1 1d       	adc	r31, r1
 1ac:	40 83       	st	Z, r20
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1156
    p[gOffset] = g;
 1ae:	1c 96       	adiw	r26, 0x0c	; 12
 1b0:	ec 91       	ld	r30, X
 1b2:	1c 97       	sbiw	r26, 0x0c	; 12
 1b4:	e6 0f       	add	r30, r22
 1b6:	f7 2f       	mov	r31, r23
 1b8:	f1 1d       	adc	r31, r1
 1ba:	20 83       	st	Z, r18
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1157
    p[bOffset] = b;
 1bc:	1d 96       	adiw	r26, 0x0d	; 13
 1be:	8c 91       	ld	r24, X
 1c0:	68 0f       	add	r22, r24
 1c2:	71 1d       	adc	r23, r1
 1c4:	fb 01       	movw	r30, r22
 1c6:	00 83       	st	Z, r16
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1159
  }
}
 1c8:	1f 91       	pop	r17
 1ca:	0f 91       	pop	r16
 1cc:	08 95       	ret
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1152
    }
    uint8_t *p;
    if (wOffset == rOffset) { // Is an RGB-type strip
      p = &pixels[n * 3];    // 3 bytes per pixel
    } else {                 // Is a WRGB-type strip
      p = &pixels[n * 4];    // 4 bytes per pixel
 1ce:	66 0f       	add	r22, r22
 1d0:	77 1f       	adc	r23, r23
 1d2:	66 0f       	add	r22, r22
 1d4:	77 1f       	adc	r23, r23
 1d6:	6e 0f       	add	r22, r30
 1d8:	7f 1f       	adc	r23, r31
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1153
      p[wOffset] = 0;        // But only R,G,B passed -- set W to 0
 1da:	fb 01       	movw	r30, r22
 1dc:	e8 0f       	add	r30, r24
 1de:	f1 1d       	adc	r31, r1
 1e0:	10 82       	st	Z, r1
 1e2:	de cf       	rjmp	.-68     	; 0x1a0 <tinyNeoPixel::setPixelColor(unsigned int, unsigned char, unsigned char, unsigned char) [clone .part.1]+0x4e>

000001e4 <tinyNeoPixel::show()>:
_ZN12tinyNeoPixel4showEv():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:139
  }
  if ((!pixels) || pin >= NUM_DIGITAL_PINS)  {
    return;
  }
#else
  void tinyNeoPixel::show(void) {
 1e4:	cf 92       	push	r12
 1e6:	df 92       	push	r13
 1e8:	ef 92       	push	r14
 1ea:	ff 92       	push	r15
 1ec:	0f 93       	push	r16
 1ee:	1f 93       	push	r17
 1f0:	cf 93       	push	r28
 1f2:	df 93       	push	r29
 1f4:	cd b7       	in	r28, 0x3d	; 61
 1f6:	de b7       	in	r29, 0x3e	; 62
 1f8:	27 97       	sbiw	r28, 0x07	; 7
 1fa:	cd bf       	out	0x3d, r28	; 61
 1fc:	de bf       	out	0x3e, r29	; 62
 1fe:	8c 01       	movw	r16, r24
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:140
    volatile uint16_t i   = numBytes; // Loop counter
 200:	fc 01       	movw	r30, r24
 202:	83 81       	ldd	r24, Z+3	; 0x03
 204:	94 81       	ldd	r25, Z+4	; 0x04
 206:	89 83       	std	Y+1, r24	; 0x01
 208:	9a 83       	std	Y+2, r25	; 0x02
canShow():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.h:318
             function instead.
  */
  static uint32_t   gamma32(uint32_t x);

  #if (!defined(MILLIS_USE_TIMERNONE) && !defined(MILLIS_USE_TIMERRTC) && !defined(MILLIS_USE_TIMERRTC_XTAL) && !defined(MILLIS_USE_TIMERRTC_XOSC))
    inline bool canShow(void) { return (micros() - endTime) >= (uint32_t) latchTime; }
 20a:	68 df       	rcall	.-304    	; 0xdc <micros>
 20c:	f8 01       	movw	r30, r16
 20e:	c7 84       	ldd	r12, Z+15	; 0x0f
 210:	d0 88       	ldd	r13, Z+16	; 0x10
 212:	e1 88       	ldd	r14, Z+17	; 0x11
 214:	f2 88       	ldd	r15, Z+18	; 0x12
 216:	ab 01       	movw	r20, r22
 218:	bc 01       	movw	r22, r24
 21a:	4c 19       	sub	r20, r12
 21c:	5d 09       	sbc	r21, r13
 21e:	6e 09       	sbc	r22, r14
 220:	7f 09       	sbc	r23, r15
 222:	85 81       	ldd	r24, Z+5	; 0x05
 224:	96 81       	ldd	r25, Z+6	; 0x06
 226:	b0 e0       	ldi	r27, 0x00	; 0
 228:	a0 e0       	ldi	r26, 0x00	; 0
_ZN12tinyNeoPixel4showEv():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:148
  // put a delay at the end of the function, the ending time is noted and
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  while (!canShow());
 22a:	48 17       	cp	r20, r24
 22c:	59 07       	cpc	r21, r25
 22e:	6a 07       	cpc	r22, r26
 230:	7b 07       	cpc	r23, r27
 232:	58 f3       	brcs	.-42     	; 0x20a <tinyNeoPixel::show()+0x26>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:199
  //   * b (bit number for speeds that don't have to unroll the loop)
  //     is given constraint "+r", which can assign it to any register.
  //     But the code uses LDI on it. LDI doesn't work on every register,
  //     it must have the "+d" constraint to guarantee an upper register.

  noInterrupts(); // Need 100% focus on instruction timing
 234:	f8 94       	cli
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:210
  // run at those speeds, only that - if they do - you can control WS2812s
  // with them.


  volatile uint8_t
   *ptr = pixels,   // Pointer to next byte
 236:	a1 85       	ldd	r26, Z+9	; 0x09
 238:	b2 85       	ldd	r27, Z+10	; 0x0a
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:211
    b   = *ptr++,   // Current byte value
 23a:	7d 01       	movw	r14, r26
 23c:	ff ef       	ldi	r31, 0xFF	; 255
 23e:	ef 1a       	sub	r14, r31
 240:	ff 0a       	sbc	r15, r31
 242:	8c 91       	ld	r24, X
 244:	8b 83       	std	Y+3, r24	; 0x03
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:734
    // 25 inst. clocks per bit: HHHHHHHxxxxxxxLLLLLLLLLLL      H:7 x:7 L11
    // ST instructions:         ^      ^      ^       (T=0,7,14)

    volatile uint8_t next, bit;

    hi   = *port |  pinMask;
 246:	f8 01       	movw	r30, r16
 248:	a3 89       	ldd	r26, Z+19	; 0x13
 24a:	b4 89       	ldd	r27, Z+20	; 0x14
 24c:	9c 91       	ld	r25, X
 24e:	85 89       	ldd	r24, Z+21	; 0x15
 250:	98 2b       	or	r25, r24
 252:	9c 83       	std	Y+4, r25	; 0x04
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:735
    lo   = *port & ~pinMask;
 254:	9c 91       	ld	r25, X
 256:	80 95       	com	r24
 258:	89 23       	and	r24, r25
 25a:	8d 83       	std	Y+5, r24	; 0x05
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:736
    next = lo;
 25c:	8d 81       	ldd	r24, Y+5	; 0x05
 25e:	8e 83       	std	Y+6, r24	; 0x06
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:737
    bit  = 8;
 260:	88 e0       	ldi	r24, 0x08	; 8
 262:	8f 83       	std	Y+7, r24	; 0x07
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:776
      [bit]   "+d" (bit),
      [next]  "+r" (next),
      [count] "+w" (i)
    : [port]   "e" (port),
      [hi]     "r" (hi),
      [lo]     "r" (lo));
 264:	5c 81       	ldd	r21, Y+4	; 0x04
 266:	6d 81       	ldd	r22, Y+5	; 0x05
 268:	4b 81       	ldd	r20, Y+3	; 0x03
 26a:	3f 81       	ldd	r19, Y+7	; 0x07
 26c:	2e 81       	ldd	r18, Y+6	; 0x06
 26e:	89 81       	ldd	r24, Y+1	; 0x01
 270:	9a 81       	ldd	r25, Y+2	; 0x02
 272:	f7 01       	movw	r30, r14

00000274 <_head20>:
 274:	5c 93       	st	X, r21
 276:	47 fd       	sbrc	r20, 7
 278:	25 2f       	mov	r18, r21
 27a:	3a 95       	dec	r19
 27c:	00 00       	nop
 27e:	00 c0       	rjmp	.+0      	; 0x280 <_head20+0xc>
 280:	2c 93       	st	X, r18
 282:	26 2f       	mov	r18, r22
 284:	41 f0       	breq	.+16     	; 0x296 <_nextbyte20>
 286:	44 1f       	adc	r20, r20
 288:	00 c0       	rjmp	.+0      	; 0x28a <_head20+0x16>
 28a:	00 00       	nop
 28c:	6c 93       	st	X, r22
 28e:	01 d0       	rcall	.+2      	; 0x292 <_onlydelay20>
 290:	f1 cf       	rjmp	.-30     	; 0x274 <_head20>

00000292 <_onlydelay20>:
 292:	00 c0       	rjmp	.+0      	; 0x294 <_onlydelay20+0x2>
 294:	08 95       	ret

00000296 <_nextbyte20>:
 296:	38 e0       	ldi	r19, 0x08	; 8
 298:	41 91       	ld	r20, Z+
 29a:	00 00       	nop
 29c:	6c 93       	st	X, r22
 29e:	00 00       	nop
 2a0:	00 c0       	rjmp	.+0      	; 0x2a2 <_nextbyte20+0xc>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <_nextbyte20+0xe>
 2a4:	01 97       	sbiw	r24, 0x01	; 1
 2a6:	31 f7       	brne	.-52     	; 0x274 <_head20>
 2a8:	4b 83       	std	Y+3, r20	; 0x03
 2aa:	3f 83       	std	Y+7, r19	; 0x07
 2ac:	2e 83       	std	Y+6, r18	; 0x06
 2ae:	89 83       	std	Y+1, r24	; 0x01
 2b0:	9a 83       	std	Y+2, r25	; 0x02
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1116
    #error "CPU SPEED NOT SUPPORTED"
  #endif



  interrupts();
 2b2:	78 94       	sei
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1118
  #if (!defined(MILLIS_USE_TIMERNONE) && !defined(MILLIS_USE_TIMERRTC) && !defined(MILLIS_USE_TIMERRTC_XTAL) && !defined(MILLIS_USE_TIMERRTC_XOSC))
    endTime = micros();
 2b4:	13 df       	rcall	.-474    	; 0xdc <micros>
 2b6:	f8 01       	movw	r30, r16
 2b8:	67 87       	std	Z+15, r22	; 0x0f
 2ba:	70 8b       	std	Z+16, r23	; 0x10
 2bc:	81 8b       	std	Z+17, r24	; 0x11
 2be:	92 8b       	std	Z+18, r25	; 0x12
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1124
    // Save EOD time for latch on next call
    #pragma message("micros() present. This library assumes the canonical 50 us latch delay; some pixels will wait as long as 250us. In these cases, you must be sure to not call show more often. See documentation.")
  #else
    #pragma message("micros() is not available because millis is disabled from the tools subemnu. It is your responsibility to ensure a sufficient time has passed between calls to show(). See documentation.")
  #endif
}
 2c0:	27 96       	adiw	r28, 0x07	; 7
 2c2:	cd bf       	out	0x3d, r28	; 61
 2c4:	de bf       	out	0x3e, r29	; 62
 2c6:	df 91       	pop	r29
 2c8:	cf 91       	pop	r28
 2ca:	1f 91       	pop	r17
 2cc:	0f 91       	pop	r16
 2ce:	ff 90       	pop	r15
 2d0:	ef 90       	pop	r14
 2d2:	df 90       	pop	r13
 2d4:	cf 90       	pop	r12
 2d6:	08 95       	ret

000002d8 <digitalWrite.constprop.5>:
digitalWrite.constprop.5():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:240
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
 2d8:	cf 93       	push	r28
 2da:	df 93       	push	r29
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:243
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 2dc:	86 30       	cpi	r24, 0x06	; 6
 2de:	78 f5       	brcc	.+94     	; 0x33e <digitalWrite.constprop.5+0x66>
check_valid_digital_pin():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Arduino.h:873
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 2e0:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite.constprop.5():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:243
 2e2:	dc 01       	movw	r26, r24
 2e4:	ae 54       	subi	r26, 0x4E	; 78
 2e6:	b7 47       	sbci	r27, 0x77	; 119
 2e8:	2c 91       	ld	r18, X
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:244
  if (bit_mask == NOT_A_PIN) {
 2ea:	2f 3f       	cpi	r18, 0xFF	; 255
 2ec:	41 f1       	breq	.+80     	; 0x33e <digitalWrite.constprop.5+0x66>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:249
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
 2ee:	fc 01       	movw	r30, r24
 2f0:	e4 55       	subi	r30, 0x54	; 84
 2f2:	f7 47       	sbci	r31, 0x77	; 119
 2f4:	e0 81       	ld	r30, Z
 2f6:	30 e2       	ldi	r19, 0x20	; 32
 2f8:	e3 9f       	mul	r30, r19
 2fa:	f0 01       	movw	r30, r0
 2fc:	11 24       	eor	r1, r1
 2fe:	fc 5f       	subi	r31, 0xFC	; 252
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:258
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
 300:	26 83       	std	Z+6, r18	; 0x06
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:282
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 302:	30 81       	ld	r19, Z
 304:	23 23       	and	r18, r19
 306:	89 f4       	brne	.+34     	; 0x32a <digitalWrite.constprop.5+0x52>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:289
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
 308:	ec 01       	movw	r28, r24
 30a:	ca 55       	subi	r28, 0x5A	; 90
 30c:	d7 47       	sbci	r29, 0x77	; 119
 30e:	28 81       	ld	r18, Y
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:292

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 310:	30 97       	sbiw	r30, 0x00	; 0
 312:	c1 f0       	breq	.+48     	; 0x344 <digitalWrite.constprop.5+0x6c>
 314:	28 30       	cpi	r18, 0x08	; 8
 316:	b0 f4       	brcc	.+44     	; 0x344 <digitalWrite.constprop.5+0x6c>
 318:	70 96       	adiw	r30, 0x10	; 16
 31a:	e2 0f       	add	r30, r18
 31c:	f1 1d       	adc	r31, r1
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:295

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 31e:	3f b7       	in	r19, 0x3f	; 63
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:296
    cli();
 320:	f8 94       	cli
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:300

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 322:	20 81       	ld	r18, Z
 324:	27 7f       	andi	r18, 0xF7	; 247
 326:	20 83       	st	Z, r18
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:307
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
    }

    /* Restore system status */
    SREG = status;
 328:	3f bf       	out	0x3f, r19	; 63
turnOffPWM():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:107
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & __PeripheralControl;
 32a:	80 56       	subi	r24, 0x60	; 96
 32c:	97 47       	sbci	r25, 0x77	; 119
 32e:	fc 01       	movw	r30, r24
 330:	80 81       	ld	r24, Z
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:109
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
 332:	88 23       	and	r24, r24
 334:	21 f0       	breq	.+8      	; 0x33e <digitalWrite.constprop.5+0x66>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:116
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
  // TCB_t *timerB;

  switch (digital_pin_timer) {
 336:	80 31       	cpi	r24, 0x10	; 16
 338:	41 f0       	breq	.+16     	; 0x34a <digitalWrite.constprop.5+0x72>
 33a:	80 38       	cpi	r24, 0x80	; 128
 33c:	a9 f0       	breq	.+42     	; 0x368 <digitalWrite.constprop.5+0x90>
digitalWrite.constprop.5():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:320
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	08 95       	ret
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:292

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 344:	f0 e0       	ldi	r31, 0x00	; 0
 346:	e0 e0       	ldi	r30, 0x00	; 0
 348:	ea cf       	rjmp	.-44     	; 0x31e <digitalWrite.constprop.5+0x46>
turnOffPWM():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:113
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
 34a:	8c 91       	ld	r24, X
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:125
    {
      #if !defined(TCA_BUFFERED_3PIN)
        // uint8_t *timer_cmp_out;
        /* Bit position will give output channel */
        #ifdef __AVR_ATtinyxy2__
          if (bit_mask == 0x80) {
 34c:	80 38       	cpi	r24, 0x80	; 128
 34e:	51 f0       	breq	.+20     	; 0x364 <digitalWrite.constprop.5+0x8c>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:128
            bit_mask = 1;         // on the xy2, WO0 is on PA7
          }
          if (bit_mask > 0x04) {  // -> bit_pos > 2 -> output channel controlled by HCMP
 350:	85 30       	cpi	r24, 0x05	; 5
 352:	08 f0       	brcs	.+2      	; 0x356 <digitalWrite.constprop.5+0x7e>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:129
            bit_mask <<= 1;       // mind the gap (between LCMP and HCMP)
 354:	88 0f       	add	r24, r24
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif
        TCA0.SPLIT.CTRLB &= ~bit_mask;
 356:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <digital_pin_to_bit_mask+0x7f814f>
 35a:	80 95       	com	r24
 35c:	89 23       	and	r24, r25
 35e:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_bit_mask+0x7f814f>
 362:	ed cf       	rjmp	.-38     	; 0x33e <digitalWrite.constprop.5+0x66>
digitalWrite.constprop.5():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:126
      #if !defined(TCA_BUFFERED_3PIN)
        // uint8_t *timer_cmp_out;
        /* Bit position will give output channel */
        #ifdef __AVR_ATtinyxy2__
          if (bit_mask == 0x80) {
            bit_mask = 1;         // on the xy2, WO0 is on PA7
 364:	81 e0       	ldi	r24, 0x01	; 1
 366:	f7 cf       	rjmp	.-18     	; 0x356 <digitalWrite.constprop.5+0x7e>
turnOffPWM():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:157
    /* We don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
 368:	10 92 80 06 	sts	0x0680, r1	; 0x800680 <digital_pin_to_bit_mask+0x7f7dce>
 36c:	e8 cf       	rjmp	.-48     	; 0x33e <digitalWrite.constprop.5+0x66>

0000036e <pinMode>:
pinMode():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 36e:	86 30       	cpi	r24, 0x06	; 6
 370:	e0 f4       	brcc	.+56     	; 0x3aa <pinMode+0x3c>
check_valid_digital_pin():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Arduino.h:873
 372:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:44
 374:	fc 01       	movw	r30, r24
 376:	ee 54       	subi	r30, 0x4E	; 78
 378:	f7 47       	sbci	r31, 0x77	; 119
 37a:	20 81       	ld	r18, Z
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:45
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
 37c:	2f 3f       	cpi	r18, 0xFF	; 255
 37e:	a9 f0       	breq	.+42     	; 0x3aa <pinMode+0x3c>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:48
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
 380:	fc 01       	movw	r30, r24
 382:	e4 55       	subi	r30, 0x54	; 84
 384:	f7 47       	sbci	r31, 0x77	; 119
 386:	e0 81       	ld	r30, Z
 388:	30 e2       	ldi	r19, 0x20	; 32
 38a:	e3 9f       	mul	r30, r19
 38c:	f0 01       	movw	r30, r0
 38e:	11 24       	eor	r1, r1
 390:	fc 5f       	subi	r31, 0xFC	; 252
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:49
  if (mode & 0x01) {
 392:	66 23       	and	r22, r22
 394:	59 f0       	breq	.+22     	; 0x3ac <pinMode+0x3e>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:51
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 396:	21 83       	std	Z+1, r18	; 0x01
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:77
  // then load with displacement 2 clocks. IFF the compiler puts this pointer into Y or Z, it is faster and smaller
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
 398:	8a 55       	subi	r24, 0x5A	; 90
 39a:	97 47       	sbci	r25, 0x77	; 119
 39c:	dc 01       	movw	r26, r24
 39e:	8c 91       	ld	r24, X
 3a0:	e8 0f       	add	r30, r24
 3a2:	f1 1d       	adc	r31, r1
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:78
  bit_mask = *(port_base + 0x10);
 3a4:	80 89       	ldd	r24, Z+16	; 0x10
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 3a6:	87 7f       	andi	r24, 0xF7	; 247
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:84
  }
  *(port_base + 0x10) = bit_mask;
 3a8:	80 8b       	std	Z+16, r24	; 0x10
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:85
}
 3aa:	08 95       	ret
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:53
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else { // otherwise it's input so we write DIRCLR
    *(port_base + 2) = bit_mask;
 3ac:	22 83       	std	Z+2, r18	; 0x02
 3ae:	f4 cf       	rjmp	.-24     	; 0x398 <pinMode+0x2a>

000003b0 <tinyNeoPixel::begin()>:
_ZN12tinyNeoPixel5beginEv():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:76
    free(pixels);
  }
  pinMode(pin, INPUT);
}

void tinyNeoPixel::begin(void) {
 3b0:	cf 93       	push	r28
 3b2:	df 93       	push	r29
 3b4:	ec 01       	movw	r28, r24
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:77
  pinMode(pin, OUTPUT);
 3b6:	61 e0       	ldi	r22, 0x01	; 1
 3b8:	8f 81       	ldd	r24, Y+7	; 0x07
 3ba:	d9 df       	rcall	.-78     	; 0x36e <pinMode>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:78
  digitalWrite(pin, LOW);
 3bc:	8f 81       	ldd	r24, Y+7	; 0x07
 3be:	8c df       	rcall	.-232    	; 0x2d8 <digitalWrite.constprop.5>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:79
  begun = true;
 3c0:	81 e0       	ldi	r24, 0x01	; 1
 3c2:	88 83       	st	Y, r24
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:80
}
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	08 95       	ret

000003ca <tinyNeoPixel::clear()>:
_ZN12tinyNeoPixel5clearEv():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1440
uint8_t tinyNeoPixel::getBrightness(void) const {
  return brightness - 1;
}

void tinyNeoPixel::clear() {
  memset(pixels, 0, numBytes);
 3ca:	fc 01       	movw	r30, r24
 3cc:	43 81       	ldd	r20, Z+3	; 0x03
 3ce:	54 81       	ldd	r21, Z+4	; 0x04
 3d0:	70 e0       	ldi	r23, 0x00	; 0
 3d2:	60 e0       	ldi	r22, 0x00	; 0
 3d4:	81 85       	ldd	r24, Z+9	; 0x09
 3d6:	92 85       	ldd	r25, Z+10	; 0x0a
 3d8:	50 c2       	rjmp	.+1184   	; 0x87a <memset>

000003da <__vector_14>:
__vector_14():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:206
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      // Common Interrupt header for TCB, TCA and TCD;
      // Clears the Timer Interrupt flag and pushes the CPU Registers
      // 7 words / 7 clocks
      __asm__ __volatile__(
 3da:	8f 93       	push	r24
 3dc:	81 e0       	ldi	r24, 0x01	; 1
 3de:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <digital_pin_to_bit_mask+0x7f81db>
 3e2:	8f b7       	in	r24, 0x3f	; 63
 3e4:	8f 93       	push	r24
 3e6:	ef 93       	push	r30
 3e8:	ff 93       	push	r31
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:317
        [MIINC]  "M" ((0x0000 - MILLIS_INC) & 0xFF),
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
  */

      __asm__ __volatile__(
 3ea:	e2 e3       	ldi	r30, 0x32	; 50
 3ec:	ff e3       	ldi	r31, 0x3F	; 63
 3ee:	9f 93       	push	r25
 3f0:	68 94       	set
 3f2:	8f ef       	ldi	r24, 0xFF	; 255
 3f4:	0d c0       	rjmp	.+26     	; 0x410 <sub4>

000003f6 <ovf_end>:
 3f6:	e8 94       	clt
 3f8:	84 81       	ldd	r24, Z+4	; 0x04
 3fa:	95 81       	ldd	r25, Z+5	; 0x05
 3fc:	80 5d       	subi	r24, 0xD0	; 208
 3fe:	9c 4f       	sbci	r25, 0xFC	; 252
 400:	84 83       	std	Z+4, r24	; 0x04
 402:	95 83       	std	Z+5, r25	; 0x05
 404:	88 5e       	subi	r24, 0xE8	; 232
 406:	93 40       	sbci	r25, 0x03	; 3
 408:	80 f0       	brcs	.+32     	; 0x42a <sub_end>
 40a:	84 83       	std	Z+4, r24	; 0x04
 40c:	95 83       	std	Z+5, r25	; 0x05
 40e:	8f ef       	ldi	r24, 0xFF	; 255

00000410 <sub4>:
 410:	90 81       	ld	r25, Z
 412:	98 1b       	sub	r25, r24
 414:	91 93       	st	Z+, r25
 416:	90 81       	ld	r25, Z
 418:	9f 4f       	sbci	r25, 0xFF	; 255
 41a:	91 93       	st	Z+, r25
 41c:	90 81       	ld	r25, Z
 41e:	9f 4f       	sbci	r25, 0xFF	; 255
 420:	91 93       	st	Z+, r25
 422:	90 81       	ld	r25, Z
 424:	9f 4f       	sbci	r25, 0xFF	; 255
 426:	91 93       	st	Z+, r25
 428:	36 f3       	brts	.-52     	; 0x3f6 <ovf_end>

0000042a <sub_end>:
 42a:	9f 91       	pop	r25
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:379
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
    #endif /* (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) */
    // Common ISR Epilogue for TCA, TCB and TCD, popping register in reverse Order
    // 6 words, 14 clocks
    __asm__ __volatile__(
 42c:	ff 91       	pop	r31
 42e:	ef 91       	pop	r30
 430:	8f 91       	pop	r24
 432:	8f bf       	out	0x3f, r24	; 63
 434:	8f 91       	pop	r24
 436:	18 95       	reti

00000438 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]>:
_ZN12tinyNeoPixelC2Ejhh.constprop.3():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:52
  -------------------------------------------------------------------------*/

#include "tinyNeoPixel.h"

// Constructor when length, pin and type are known at compile-time:
tinyNeoPixel::tinyNeoPixel(uint16_t n, uint8_t p, neoPixelType t) :
 438:	cf 92       	push	r12
 43a:	df 92       	push	r13
 43c:	ef 92       	push	r14
 43e:	ff 92       	push	r15
 440:	1f 93       	push	r17
 442:	cf 93       	push	r28
 444:	df 93       	push	r29
 446:	ec 01       	movw	r28, r24
 448:	6b 01       	movw	r12, r22
 44a:	14 2f       	mov	r17, r20
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:53
  begun(false), brightness(0), pixels(NULL), latchTime(50), endTime(0) {
 44c:	18 82       	st	Y, r1
 44e:	82 e3       	ldi	r24, 0x32	; 50
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	8d 83       	std	Y+5, r24	; 0x05
 454:	9e 83       	std	Y+6, r25	; 0x06
 456:	18 86       	std	Y+8, r1	; 0x08
 458:	1f 86       	std	Y+15, r1	; 0x0f
 45a:	18 8a       	std	Y+16, r1	; 0x10
 45c:	19 8a       	std	Y+17, r1	; 0x11
 45e:	1a 8a       	std	Y+18, r1	; 0x12
updateType():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:105
}

void tinyNeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW

  wOffset = (t >> 6) & 0b11; // See notes in header file
 460:	81 e0       	ldi	r24, 0x01	; 1
 462:	8e 87       	std	Y+14, r24	; 0x0e
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:106
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
 464:	8b 87       	std	Y+11, r24	; 0x0b
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:107
  gOffset = (t >> 2) & 0b11;
 466:	1c 86       	std	Y+12, r1	; 0x0c
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:108
  bOffset =  t       & 0b11;
 468:	82 e0       	ldi	r24, 0x02	; 2
 46a:	8d 87       	std	Y+13, r24	; 0x0d
updateLength():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:93
  if (pixels) {
    free(pixels);  // Free existing data (if any)
  }

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((wOffset == rOffset) ? 3 : 4);
 46c:	7b 01       	movw	r14, r22
 46e:	ee 0c       	add	r14, r14
 470:	ff 1c       	adc	r15, r15
 472:	e6 0e       	add	r14, r22
 474:	f7 1e       	adc	r15, r23
 476:	eb 82       	std	Y+3, r14	; 0x03
 478:	fc 82       	std	Y+4, r15	; 0x04
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:94
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 47a:	c7 01       	movw	r24, r14
 47c:	d9 d0       	rcall	.+434    	; 0x630 <malloc>
 47e:	89 87       	std	Y+9, r24	; 0x09
 480:	9a 87       	std	Y+10, r25	; 0x0a
 482:	00 97       	sbiw	r24, 0x00	; 0
 484:	51 f1       	breq	.+84     	; 0x4da <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]+0xa2>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:95
    memset(pixels, 0, numBytes);
 486:	a7 01       	movw	r20, r14
 488:	70 e0       	ldi	r23, 0x00	; 0
 48a:	60 e0       	ldi	r22, 0x00	; 0
 48c:	f6 d1       	rcall	.+1004   	; 0x87a <memset>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:96
    numLEDs = n;
 48e:	c9 82       	std	Y+1, r12	; 0x01
 490:	da 82       	std	Y+2, r13	; 0x02
setPin():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1131
// Set the output pin number
void tinyNeoPixel::setPin(uint8_t p) {
  if (begun && (pin < NUM_DIGITAL_PINS)) {
    pinMode(pin, INPUT);
  }
  pin = p;
 492:	1f 83       	std	Y+7, r17	; 0x07
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1132
  if (begun) {
 494:	88 81       	ld	r24, Y
 496:	88 23       	and	r24, r24
 498:	29 f0       	breq	.+10     	; 0x4a4 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]+0x6c>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1133
    pinMode(p, OUTPUT);
 49a:	61 e0       	ldi	r22, 0x01	; 1
 49c:	81 2f       	mov	r24, r17
 49e:	67 df       	rcall	.-306    	; 0x36e <pinMode>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1134
    digitalWrite(p, LOW);
 4a0:	81 2f       	mov	r24, r17
 4a2:	1a df       	rcall	.-460    	; 0x2d8 <digitalWrite.constprop.5>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1136
  }
  port    = portOutputRegister(digitalPinToPort(p));
 4a4:	81 2f       	mov	r24, r17
 4a6:	90 e0       	ldi	r25, 0x00	; 0
 4a8:	fc 01       	movw	r30, r24
 4aa:	e4 55       	subi	r30, 0x54	; 84
 4ac:	f7 47       	sbci	r31, 0x77	; 119
 4ae:	20 81       	ld	r18, Z
 4b0:	22 23       	and	r18, r18
 4b2:	c1 f0       	breq	.+48     	; 0x4e4 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]+0xac>
_ZN12tinyNeoPixelC2Ejhh.constprop.3():
 4b4:	30 e0       	ldi	r19, 0x00	; 0
 4b6:	20 e0       	ldi	r18, 0x00	; 0
setPin():
 4b8:	2c 5f       	subi	r18, 0xFC	; 252
 4ba:	3f 4f       	sbci	r19, 0xFF	; 255
 4bc:	2b 8b       	std	Y+19, r18	; 0x13
 4be:	3c 8b       	std	Y+20, r19	; 0x14
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1137
  pinMask = digitalPinToBitMask(p);
 4c0:	8e 54       	subi	r24, 0x4E	; 78
 4c2:	97 47       	sbci	r25, 0x77	; 119
 4c4:	fc 01       	movw	r30, r24
 4c6:	80 81       	ld	r24, Z
 4c8:	8d 8b       	std	Y+21, r24	; 0x15
_ZN12tinyNeoPixelC2Ejhh.constprop.3():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:57
tinyNeoPixel::tinyNeoPixel(uint16_t n, uint8_t p, neoPixelType t) :
  begun(false), brightness(0), pixels(NULL), latchTime(50), endTime(0) {
  updateType(t);
  updateLength(n);
  setPin(p);
}
 4ca:	df 91       	pop	r29
 4cc:	cf 91       	pop	r28
 4ce:	1f 91       	pop	r17
 4d0:	ff 90       	pop	r15
 4d2:	ef 90       	pop	r14
 4d4:	df 90       	pop	r13
 4d6:	cf 90       	pop	r12
 4d8:	08 95       	ret
updateLength():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:98
  numBytes = n * ((wOffset == rOffset) ? 3 : 4);
  if ((pixels = (uint8_t *)malloc(numBytes))) {
    memset(pixels, 0, numBytes);
    numLEDs = n;
  } else {
    numLEDs = numBytes = 0;
 4da:	1b 82       	std	Y+3, r1	; 0x03
 4dc:	1c 82       	std	Y+4, r1	; 0x04
 4de:	19 82       	std	Y+1, r1	; 0x01
 4e0:	1a 82       	std	Y+2, r1	; 0x02
 4e2:	d7 cf       	rjmp	.-82     	; 0x492 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]+0x5a>
_ZN12tinyNeoPixelC2Ejhh.constprop.3():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1136
  pin = p;
  if (begun) {
    pinMode(p, OUTPUT);
    digitalWrite(p, LOW);
  }
  port    = portOutputRegister(digitalPinToPort(p));
 4e4:	20 e0       	ldi	r18, 0x00	; 0
 4e6:	34 e0       	ldi	r19, 0x04	; 4
 4e8:	e7 cf       	rjmp	.-50     	; 0x4b8 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]+0x80>

000004ea <main>:
main():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1536
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
 4ea:	88 ed       	ldi	r24, 0xD8	; 216
 4ec:	90 e0       	ldi	r25, 0x00	; 0
 4ee:	84 bf       	out	0x34, r24	; 52
 4f0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <digital_pin_to_bit_mask+0x7f77af>
init_ADC0():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1651


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
 4f4:	e0 e0       	ldi	r30, 0x00	; 0
 4f6:	f6 e0       	ldi	r31, 0x06	; 6
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1672
   **************************************************************************/
    //                              30 MHz / 32 = 937 kHz,  32 MHz / 32 =  1 MHz.
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      pADC->CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      pADC->CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 4f8:	83 e5       	ldi	r24, 0x53	; 83
 4fa:	82 83       	std	Z+2, r24	; 0x02
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1683
      pADC->CTRLC  =  ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      pADC->SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      pADC->SAMPCTRL = (13);   // 15 ADC clock,s 12 us
 4fc:	8d e0       	ldi	r24, 0x0D	; 13
 4fe:	85 83       	std	Z+5, r24	; 0x05
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1687
    #else
      pADC->SAMPCTRL = (10); // 12 ADC clocks, 12 us
    #endif
    pADC->CTRLD    = ADC_INITDLY_DLY16_gc;
 500:	80 e2       	ldi	r24, 0x20	; 32
 502:	83 83       	std	Z+3, r24	; 0x03
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1688
    pADC->CTRLA    = ADC_ENABLE_bm;
 504:	81 e0       	ldi	r24, 0x01	; 1
 506:	80 83       	st	Z, r24
init_TCA0():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1778

void __attribute__((weak)) init_TCA0() {
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
 508:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <digital_pin_to_bit_mask+0x7f7950>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1782
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
 50c:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <digital_pin_to_bit_mask+0x7f8151>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1783
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 510:	9e ef       	ldi	r25, 0xFE	; 254
 512:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <digital_pin_to_bit_mask+0x7f8174>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1784
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 516:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <digital_pin_to_bit_mask+0x7f8175>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1785
    TCA0.SPLIT.CTRLA   = (TIMERA_PRESCALER_bm | TCA_SPLIT_ENABLE_bm);
 51a:	9b e0       	ldi	r25, 0x0B	; 11
 51c:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <digital_pin_to_bit_mask+0x7f814e>
init_millis():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1427
      #endif
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD_t* pTCD;
      _fastPtr_d(pTCD, &TCD0);
 520:	e0 e8       	ldi	r30, 0x80	; 128
 522:	fa e0       	ldi	r31, 0x0A	; 10
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1428
      pTCD->CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; // essentially, this is TOP
 524:	2d ef       	ldi	r18, 0xFD	; 253
 526:	31 e0       	ldi	r19, 0x01	; 1
 528:	26 a7       	std	Z+46, r18	; 0x2e
 52a:	37 a7       	std	Z+47, r19	; 0x2f
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1429
      pTCD->CTRLB          = 0x00; // oneramp mode
 52c:	11 82       	std	Z+1, r1	; 0x01
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1430
      pTCD->CTRLC          = 0x80;
 52e:	90 e8       	ldi	r25, 0x80	; 128
 530:	92 83       	std	Z+2, r25	; 0x02
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1431
      pTCD->INTCTRL        = 0x01; // enable interrupt
 532:	84 87       	std	Z+12, r24	; 0x0c
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1432
      pTCD->CTRLA          = TIMERD0_PRESCALER | 0x01; // set clock source and enable!
 534:	81 e1       	ldi	r24, 0x11	; 17
 536:	80 83       	st	Z, r24
main():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:53
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 538:	78 94       	sei
setup():
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:14
tinyNeoPixel leds6 = tinyNeoPixel(NUMLEDS6, PIN_PA6, NEO_GRB );
tinyNeoPixel leds7 = tinyNeoPixel(NUMLEDS7, PIN_PA7, NEO_GRB);

void setup() {

leds6.begin();
 53a:	8c e1       	ldi	r24, 0x1C	; 28
 53c:	9f e3       	ldi	r25, 0x3F	; 63
 53e:	38 df       	rcall	.-400    	; 0x3b0 <tinyNeoPixel::begin()>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:15
leds7.begin();
 540:	86 e0       	ldi	r24, 0x06	; 6
 542:	9f e3       	ldi	r25, 0x3F	; 63
 544:	35 df       	rcall	.-406    	; 0x3b0 <tinyNeoPixel::begin()>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:17

  leds6.clear();  // LED turns off.
 546:	8c e1       	ldi	r24, 0x1C	; 28
 548:	9f e3       	ldi	r25, 0x3F	; 63
 54a:	3f df       	rcall	.-386    	; 0x3ca <tinyNeoPixel::clear()>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:18
  leds7.clear();  // LED turns off.
 54c:	86 e0       	ldi	r24, 0x06	; 6
 54e:	9f e3       	ldi	r25, 0x3F	; 63
 550:	3c df       	rcall	.-392    	; 0x3ca <tinyNeoPixel::clear()>
delay():
 552:	a4 dd       	rcall	.-1208   	; 0x9c <delay.part.0.constprop.1>
loop():
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:25
delay (1000);

}
void loop() { /* empty loop */

leds6.begin();
 554:	8c e1       	ldi	r24, 0x1C	; 28
 556:	9f e3       	ldi	r25, 0x3F	; 63
 558:	2b df       	rcall	.-426    	; 0x3b0 <tinyNeoPixel::begin()>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:26
leds7.begin();
 55a:	86 e0       	ldi	r24, 0x06	; 6
 55c:	9f e3       	ldi	r25, 0x3F	; 63
 55e:	28 df       	rcall	.-432    	; 0x3b0 <tinyNeoPixel::begin()>
setPixelColor():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1142
  pinMask = digitalPinToBitMask(p);
}

// Set pixel color from separate R,G,B components:
void tinyNeoPixel::setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
  if (n < numLEDs) {
 560:	80 91 1d 3f 	lds	r24, 0x3F1D	; 0x803f1d <leds6+0x1>
 564:	90 91 1e 3f 	lds	r25, 0x3F1E	; 0x803f1e <leds6+0x2>
 568:	89 2b       	or	r24, r25
 56a:	41 f0       	breq	.+16     	; 0x57c <main+0x92>
 56c:	05 e0       	ldi	r16, 0x05	; 5
 56e:	2b e7       	ldi	r18, 0x7B	; 123
 570:	46 e9       	ldi	r20, 0x96	; 150
 572:	70 e0       	ldi	r23, 0x00	; 0
 574:	60 e0       	ldi	r22, 0x00	; 0
 576:	8c e1       	ldi	r24, 0x1C	; 28
 578:	9f e3       	ldi	r25, 0x3F	; 63
 57a:	eb dd       	rcall	.-1066   	; 0x152 <tinyNeoPixel::setPixelColor(unsigned int, unsigned char, unsigned char, unsigned char) [clone .part.1]>
main():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
 57c:	d0 e0       	ldi	r29, 0x00	; 0
 57e:	c0 e0       	ldi	r28, 0x00	; 0
setPixelColor():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:1142
 580:	80 91 07 3f 	lds	r24, 0x3F07	; 0x803f07 <__data_end+0x1>
 584:	90 91 08 3f 	lds	r25, 0x3F08	; 0x803f08 <__data_end+0x2>
 588:	c8 17       	cp	r28, r24
 58a:	d9 07       	cpc	r29, r25
 58c:	38 f4       	brcc	.+14     	; 0x59c <main+0xb2>
 58e:	0a ef       	ldi	r16, 0xFA	; 250
 590:	20 e0       	ldi	r18, 0x00	; 0
 592:	40 e0       	ldi	r20, 0x00	; 0
 594:	be 01       	movw	r22, r28
 596:	86 e0       	ldi	r24, 0x06	; 6
 598:	9f e3       	ldi	r25, 0x3F	; 63
 59a:	db dd       	rcall	.-1098   	; 0x152 <tinyNeoPixel::setPixelColor(unsigned int, unsigned char, unsigned char, unsigned char) [clone .part.1]>
loop():
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:31

 for (int i = 0; i < NUMLEDS6; i++) {  // Logo Arduino
    leds6.setPixelColor(i, 150, 123, 5);
  }
  for (int i = 0; i < NUMLEDS7; i++) {  // borde
 59c:	21 96       	adiw	r28, 0x01	; 1
 59e:	c2 31       	cpi	r28, 0x12	; 18
 5a0:	d1 05       	cpc	r29, r1
 5a2:	71 f7       	brne	.-36     	; 0x580 <main+0x96>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:35
    leds7.setPixelColor(i, 0, 0, 250);
  }

  leds6.show();
 5a4:	8c e1       	ldi	r24, 0x1C	; 28
 5a6:	9f e3       	ldi	r25, 0x3F	; 63
 5a8:	1d de       	rcall	.-966    	; 0x1e4 <tinyNeoPixel::show()>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:36
  leds7.show();  // LED turns on.
 5aa:	86 e0       	ldi	r24, 0x06	; 6
 5ac:	9f e3       	ldi	r25, 0x3F	; 63
 5ae:	1a de       	rcall	.-972    	; 0x1e4 <tinyNeoPixel::show()>
delay():
 5b0:	75 dd       	rcall	.-1302   	; 0x9c <delay.part.0.constprop.1>
 5b2:	c9 cf       	rjmp	.-110    	; 0x546 <main+0x5c>

000005b4 <_GLOBAL__sub_I_leds6>:
_GLOBAL__sub_I_leds6():
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:9

#define NUMLEDS6 1 // 7  // logotipo A Industriosa
#define NUMLEDS7 18 // 4  // Bordes logos


tinyNeoPixel leds6 = tinyNeoPixel(NUMLEDS6, PIN_PA6, NEO_GRB );
 5b4:	40 e0       	ldi	r20, 0x00	; 0
 5b6:	61 e0       	ldi	r22, 0x01	; 1
 5b8:	70 e0       	ldi	r23, 0x00	; 0
 5ba:	8c e1       	ldi	r24, 0x1C	; 28
 5bc:	9f e3       	ldi	r25, 0x3F	; 63
 5be:	3c df       	rcall	.-392    	; 0x438 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]>
/Users/cybermode/Library/CloudStorage/GoogleDrive-triade@triade.es/Mi unidad/A Industriosa/2024/A Industriosa - Branding/Software/011_MegaTiny_Neopixel/011_MegaTiny_Neopixel.ino:10
tinyNeoPixel leds7 = tinyNeoPixel(NUMLEDS7, PIN_PA7, NEO_GRB);
 5c0:	41 e0       	ldi	r20, 0x01	; 1
 5c2:	62 e1       	ldi	r22, 0x12	; 18
 5c4:	70 e0       	ldi	r23, 0x00	; 0
 5c6:	86 e0       	ldi	r24, 0x06	; 6
 5c8:	9f e3       	ldi	r25, 0x3F	; 63
 5ca:	36 cf       	rjmp	.-404    	; 0x438 <tinyNeoPixel::tinyNeoPixel(unsigned int, unsigned char, unsigned char) [clone .constprop.3]>

000005cc <_GLOBAL__sub_D_leds6>:
_GLOBAL__sub_D_leds6():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:70
  begun(false), numLEDs(0), numBytes(0), pin(NOT_A_PIN), brightness(0), pixels(NULL),
  rOffset(1), gOffset(0), bOffset(2), wOffset(1), latchTime(50), endTime(0)  {
}

tinyNeoPixel::~tinyNeoPixel() {
  if (pixels) {
 5cc:	80 91 0f 3f 	lds	r24, 0x3F0F	; 0x803f0f <__data_end+0x9>
 5d0:	90 91 10 3f 	lds	r25, 0x3F10	; 0x803f10 <__data_end+0xa>
 5d4:	00 97       	sbiw	r24, 0x00	; 0
 5d6:	09 f0       	breq	.+2      	; 0x5da <_GLOBAL__sub_D_leds6+0xe>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:71
    free(pixels);
 5d8:	c7 d0       	rcall	.+398    	; 0x768 <free>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:73
  }
  pinMode(pin, INPUT);
 5da:	60 e0       	ldi	r22, 0x00	; 0
 5dc:	80 91 0d 3f 	lds	r24, 0x3F0D	; 0x803f0d <__data_end+0x7>
 5e0:	c6 de       	rcall	.-628    	; 0x36e <pinMode>
__base_dtor ():
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:70
  begun(false), numLEDs(0), numBytes(0), pin(NOT_A_PIN), brightness(0), pixels(NULL),
  rOffset(1), gOffset(0), bOffset(2), wOffset(1), latchTime(50), endTime(0)  {
}

tinyNeoPixel::~tinyNeoPixel() {
  if (pixels) {
 5e2:	80 91 25 3f 	lds	r24, 0x3F25	; 0x803f25 <leds6+0x9>
 5e6:	90 91 26 3f 	lds	r25, 0x3F26	; 0x803f26 <leds6+0xa>
 5ea:	00 97       	sbiw	r24, 0x00	; 0
 5ec:	09 f0       	breq	.+2      	; 0x5f0 <_GLOBAL__sub_D_leds6+0x24>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:71
    free(pixels);
 5ee:	bc d0       	rcall	.+376    	; 0x768 <free>
/Users/cybermode/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/libraries/tinyNeoPixel/tinyNeoPixel.cpp:73
  }
  pinMode(pin, INPUT);
 5f0:	60 e0       	ldi	r22, 0x00	; 0
 5f2:	80 91 23 3f 	lds	r24, 0x3F23	; 0x803f23 <leds6+0x7>
 5f6:	bb ce       	rjmp	.-650    	; 0x36e <pinMode>

000005f8 <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:626
 5f8:	0f d0       	rcall	.+30     	; 0x618 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:627
 5fa:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:628
 5fc:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:629
 5fe:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:630
 600:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:631
 602:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:632
 604:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:633
 606:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:634
 608:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:635
 60a:	08 95       	ret

0000060c <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 60c:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 60e:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 610:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 612:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 614:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 616:	09 94       	ijmp

00000618 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 618:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 61a:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 61c:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 61e:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 620:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:578
 622:	01 d0       	rcall	.+2      	; 0x626 <__umulhisi3+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 624:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 626:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 628:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 62a:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 62c:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 62e:	08 95       	ret

00000630 <malloc>:
malloc():
 630:	0f 93       	push	r16
 632:	1f 93       	push	r17
 634:	cf 93       	push	r28
 636:	df 93       	push	r29
 638:	82 30       	cpi	r24, 0x02	; 2
 63a:	91 05       	cpc	r25, r1
 63c:	10 f4       	brcc	.+4      	; 0x642 <malloc+0x12>
 63e:	82 e0       	ldi	r24, 0x02	; 2
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	e0 91 3e 3f 	lds	r30, 0x3F3E	; 0x803f3e <__flp>
 646:	f0 91 3f 3f 	lds	r31, 0x3F3F	; 0x803f3f <__flp+0x1>
 64a:	30 e0       	ldi	r19, 0x00	; 0
 64c:	20 e0       	ldi	r18, 0x00	; 0
 64e:	b0 e0       	ldi	r27, 0x00	; 0
 650:	a0 e0       	ldi	r26, 0x00	; 0
 652:	30 97       	sbiw	r30, 0x00	; 0
 654:	99 f4       	brne	.+38     	; 0x67c <malloc+0x4c>
 656:	21 15       	cp	r18, r1
 658:	31 05       	cpc	r19, r1
 65a:	09 f4       	brne	.+2      	; 0x65e <malloc+0x2e>
 65c:	4a c0       	rjmp	.+148    	; 0x6f2 <malloc+0xc2>
 65e:	28 1b       	sub	r18, r24
 660:	39 0b       	sbc	r19, r25
 662:	24 30       	cpi	r18, 0x04	; 4
 664:	31 05       	cpc	r19, r1
 666:	d8 f5       	brcc	.+118    	; 0x6de <malloc+0xae>
 668:	8a 81       	ldd	r24, Y+2	; 0x02
 66a:	9b 81       	ldd	r25, Y+3	; 0x03
 66c:	61 15       	cp	r22, r1
 66e:	71 05       	cpc	r23, r1
 670:	89 f1       	breq	.+98     	; 0x6d4 <malloc+0xa4>
 672:	fb 01       	movw	r30, r22
 674:	82 83       	std	Z+2, r24	; 0x02
 676:	93 83       	std	Z+3, r25	; 0x03
 678:	fe 01       	movw	r30, r28
 67a:	11 c0       	rjmp	.+34     	; 0x69e <malloc+0x6e>
 67c:	40 81       	ld	r20, Z
 67e:	51 81       	ldd	r21, Z+1	; 0x01
 680:	02 81       	ldd	r16, Z+2	; 0x02
 682:	13 81       	ldd	r17, Z+3	; 0x03
 684:	48 17       	cp	r20, r24
 686:	59 07       	cpc	r21, r25
 688:	e0 f0       	brcs	.+56     	; 0x6c2 <malloc+0x92>
 68a:	48 17       	cp	r20, r24
 68c:	59 07       	cpc	r21, r25
 68e:	99 f4       	brne	.+38     	; 0x6b6 <malloc+0x86>
 690:	10 97       	sbiw	r26, 0x00	; 0
 692:	61 f0       	breq	.+24     	; 0x6ac <malloc+0x7c>
 694:	12 96       	adiw	r26, 0x02	; 2
 696:	0c 93       	st	X, r16
 698:	12 97       	sbiw	r26, 0x02	; 2
 69a:	13 96       	adiw	r26, 0x03	; 3
 69c:	1c 93       	st	X, r17
 69e:	32 96       	adiw	r30, 0x02	; 2
 6a0:	cf 01       	movw	r24, r30
 6a2:	df 91       	pop	r29
 6a4:	cf 91       	pop	r28
 6a6:	1f 91       	pop	r17
 6a8:	0f 91       	pop	r16
 6aa:	08 95       	ret
 6ac:	00 93 3e 3f 	sts	0x3F3E, r16	; 0x803f3e <__flp>
 6b0:	10 93 3f 3f 	sts	0x3F3F, r17	; 0x803f3f <__flp+0x1>
 6b4:	f4 cf       	rjmp	.-24     	; 0x69e <malloc+0x6e>
 6b6:	21 15       	cp	r18, r1
 6b8:	31 05       	cpc	r19, r1
 6ba:	51 f0       	breq	.+20     	; 0x6d0 <malloc+0xa0>
 6bc:	42 17       	cp	r20, r18
 6be:	53 07       	cpc	r21, r19
 6c0:	38 f0       	brcs	.+14     	; 0x6d0 <malloc+0xa0>
 6c2:	a9 01       	movw	r20, r18
 6c4:	db 01       	movw	r26, r22
 6c6:	9a 01       	movw	r18, r20
 6c8:	bd 01       	movw	r22, r26
 6ca:	df 01       	movw	r26, r30
 6cc:	f8 01       	movw	r30, r16
 6ce:	c1 cf       	rjmp	.-126    	; 0x652 <malloc+0x22>
 6d0:	ef 01       	movw	r28, r30
 6d2:	f9 cf       	rjmp	.-14     	; 0x6c6 <malloc+0x96>
 6d4:	80 93 3e 3f 	sts	0x3F3E, r24	; 0x803f3e <__flp>
 6d8:	90 93 3f 3f 	sts	0x3F3F, r25	; 0x803f3f <__flp+0x1>
 6dc:	cd cf       	rjmp	.-102    	; 0x678 <malloc+0x48>
 6de:	fe 01       	movw	r30, r28
 6e0:	e2 0f       	add	r30, r18
 6e2:	f3 1f       	adc	r31, r19
 6e4:	81 93       	st	Z+, r24
 6e6:	91 93       	st	Z+, r25
 6e8:	22 50       	subi	r18, 0x02	; 2
 6ea:	31 09       	sbc	r19, r1
 6ec:	28 83       	st	Y, r18
 6ee:	39 83       	std	Y+1, r19	; 0x01
 6f0:	d7 cf       	rjmp	.-82     	; 0x6a0 <malloc+0x70>
 6f2:	20 91 3c 3f 	lds	r18, 0x3F3C	; 0x803f3c <__brkval>
 6f6:	30 91 3d 3f 	lds	r19, 0x3F3D	; 0x803f3d <__brkval+0x1>
 6fa:	23 2b       	or	r18, r19
 6fc:	41 f4       	brne	.+16     	; 0x70e <malloc+0xde>
 6fe:	20 91 02 3f 	lds	r18, 0x3F02	; 0x803f02 <__malloc_heap_start>
 702:	30 91 03 3f 	lds	r19, 0x3F03	; 0x803f03 <__malloc_heap_start+0x1>
 706:	20 93 3c 3f 	sts	0x3F3C, r18	; 0x803f3c <__brkval>
 70a:	30 93 3d 3f 	sts	0x3F3D, r19	; 0x803f3d <__brkval+0x1>
 70e:	20 91 00 3f 	lds	r18, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 712:	30 91 01 3f 	lds	r19, 0x3F01	; 0x803f01 <__DATA_REGION_ORIGIN__+0x1>
 716:	21 15       	cp	r18, r1
 718:	31 05       	cpc	r19, r1
 71a:	41 f4       	brne	.+16     	; 0x72c <malloc+0xfc>
 71c:	2d b7       	in	r18, 0x3d	; 61
 71e:	3e b7       	in	r19, 0x3e	; 62
 720:	40 91 04 3f 	lds	r20, 0x3F04	; 0x803f04 <__malloc_margin>
 724:	50 91 05 3f 	lds	r21, 0x3F05	; 0x803f05 <__malloc_margin+0x1>
 728:	24 1b       	sub	r18, r20
 72a:	35 0b       	sbc	r19, r21
 72c:	e0 91 3c 3f 	lds	r30, 0x3F3C	; 0x803f3c <__brkval>
 730:	f0 91 3d 3f 	lds	r31, 0x3F3D	; 0x803f3d <__brkval+0x1>
 734:	e2 17       	cp	r30, r18
 736:	f3 07       	cpc	r31, r19
 738:	a0 f4       	brcc	.+40     	; 0x762 <malloc+0x132>
 73a:	2e 1b       	sub	r18, r30
 73c:	3f 0b       	sbc	r19, r31
 73e:	28 17       	cp	r18, r24
 740:	39 07       	cpc	r19, r25
 742:	78 f0       	brcs	.+30     	; 0x762 <malloc+0x132>
 744:	ac 01       	movw	r20, r24
 746:	4e 5f       	subi	r20, 0xFE	; 254
 748:	5f 4f       	sbci	r21, 0xFF	; 255
 74a:	24 17       	cp	r18, r20
 74c:	35 07       	cpc	r19, r21
 74e:	48 f0       	brcs	.+18     	; 0x762 <malloc+0x132>
 750:	4e 0f       	add	r20, r30
 752:	5f 1f       	adc	r21, r31
 754:	40 93 3c 3f 	sts	0x3F3C, r20	; 0x803f3c <__brkval>
 758:	50 93 3d 3f 	sts	0x3F3D, r21	; 0x803f3d <__brkval+0x1>
 75c:	81 93       	st	Z+, r24
 75e:	91 93       	st	Z+, r25
 760:	9f cf       	rjmp	.-194    	; 0x6a0 <malloc+0x70>
 762:	f0 e0       	ldi	r31, 0x00	; 0
 764:	e0 e0       	ldi	r30, 0x00	; 0
 766:	9c cf       	rjmp	.-200    	; 0x6a0 <malloc+0x70>

00000768 <free>:
free():
 768:	cf 93       	push	r28
 76a:	df 93       	push	r29
 76c:	00 97       	sbiw	r24, 0x00	; 0
 76e:	e9 f0       	breq	.+58     	; 0x7aa <free+0x42>
 770:	fc 01       	movw	r30, r24
 772:	32 97       	sbiw	r30, 0x02	; 2
 774:	12 82       	std	Z+2, r1	; 0x02
 776:	13 82       	std	Z+3, r1	; 0x03
 778:	a0 91 3e 3f 	lds	r26, 0x3F3E	; 0x803f3e <__flp>
 77c:	b0 91 3f 3f 	lds	r27, 0x3F3F	; 0x803f3f <__flp+0x1>
 780:	ed 01       	movw	r28, r26
 782:	30 e0       	ldi	r19, 0x00	; 0
 784:	20 e0       	ldi	r18, 0x00	; 0
 786:	10 97       	sbiw	r26, 0x00	; 0
 788:	a1 f4       	brne	.+40     	; 0x7b2 <free+0x4a>
 78a:	20 81       	ld	r18, Z
 78c:	31 81       	ldd	r19, Z+1	; 0x01
 78e:	82 0f       	add	r24, r18
 790:	93 1f       	adc	r25, r19
 792:	20 91 3c 3f 	lds	r18, 0x3F3C	; 0x803f3c <__brkval>
 796:	30 91 3d 3f 	lds	r19, 0x3F3D	; 0x803f3d <__brkval+0x1>
 79a:	28 17       	cp	r18, r24
 79c:	39 07       	cpc	r19, r25
 79e:	09 f0       	breq	.+2      	; 0x7a2 <free+0x3a>
 7a0:	61 c0       	rjmp	.+194    	; 0x864 <free+0xfc>
 7a2:	e0 93 3c 3f 	sts	0x3F3C, r30	; 0x803f3c <__brkval>
 7a6:	f0 93 3d 3f 	sts	0x3F3D, r31	; 0x803f3d <__brkval+0x1>
 7aa:	df 91       	pop	r29
 7ac:	cf 91       	pop	r28
 7ae:	08 95       	ret
 7b0:	ea 01       	movw	r28, r20
 7b2:	ce 17       	cp	r28, r30
 7b4:	df 07       	cpc	r29, r31
 7b6:	e8 f5       	brcc	.+122    	; 0x832 <free+0xca>
 7b8:	4a 81       	ldd	r20, Y+2	; 0x02
 7ba:	5b 81       	ldd	r21, Y+3	; 0x03
 7bc:	9e 01       	movw	r18, r28
 7be:	41 15       	cp	r20, r1
 7c0:	51 05       	cpc	r21, r1
 7c2:	b1 f7       	brne	.-20     	; 0x7b0 <free+0x48>
 7c4:	e9 01       	movw	r28, r18
 7c6:	ea 83       	std	Y+2, r30	; 0x02
 7c8:	fb 83       	std	Y+3, r31	; 0x03
 7ca:	49 91       	ld	r20, Y+
 7cc:	59 91       	ld	r21, Y+
 7ce:	c4 0f       	add	r28, r20
 7d0:	d5 1f       	adc	r29, r21
 7d2:	ec 17       	cp	r30, r28
 7d4:	fd 07       	cpc	r31, r29
 7d6:	61 f4       	brne	.+24     	; 0x7f0 <free+0x88>
 7d8:	80 81       	ld	r24, Z
 7da:	91 81       	ldd	r25, Z+1	; 0x01
 7dc:	02 96       	adiw	r24, 0x02	; 2
 7de:	84 0f       	add	r24, r20
 7e0:	95 1f       	adc	r25, r21
 7e2:	e9 01       	movw	r28, r18
 7e4:	88 83       	st	Y, r24
 7e6:	99 83       	std	Y+1, r25	; 0x01
 7e8:	82 81       	ldd	r24, Z+2	; 0x02
 7ea:	93 81       	ldd	r25, Z+3	; 0x03
 7ec:	8a 83       	std	Y+2, r24	; 0x02
 7ee:	9b 83       	std	Y+3, r25	; 0x03
 7f0:	f0 e0       	ldi	r31, 0x00	; 0
 7f2:	e0 e0       	ldi	r30, 0x00	; 0
 7f4:	12 96       	adiw	r26, 0x02	; 2
 7f6:	8d 91       	ld	r24, X+
 7f8:	9c 91       	ld	r25, X
 7fa:	13 97       	sbiw	r26, 0x03	; 3
 7fc:	00 97       	sbiw	r24, 0x00	; 0
 7fe:	b9 f5       	brne	.+110    	; 0x86e <free+0x106>
 800:	2d 91       	ld	r18, X+
 802:	3c 91       	ld	r19, X
 804:	11 97       	sbiw	r26, 0x01	; 1
 806:	cd 01       	movw	r24, r26
 808:	02 96       	adiw	r24, 0x02	; 2
 80a:	82 0f       	add	r24, r18
 80c:	93 1f       	adc	r25, r19
 80e:	20 91 3c 3f 	lds	r18, 0x3F3C	; 0x803f3c <__brkval>
 812:	30 91 3d 3f 	lds	r19, 0x3F3D	; 0x803f3d <__brkval+0x1>
 816:	28 17       	cp	r18, r24
 818:	39 07       	cpc	r19, r25
 81a:	39 f6       	brne	.-114    	; 0x7aa <free+0x42>
 81c:	30 97       	sbiw	r30, 0x00	; 0
 81e:	51 f5       	brne	.+84     	; 0x874 <free+0x10c>
 820:	10 92 3e 3f 	sts	0x3F3E, r1	; 0x803f3e <__flp>
 824:	10 92 3f 3f 	sts	0x3F3F, r1	; 0x803f3f <__flp+0x1>
 828:	a0 93 3c 3f 	sts	0x3F3C, r26	; 0x803f3c <__brkval>
 82c:	b0 93 3d 3f 	sts	0x3F3D, r27	; 0x803f3d <__brkval+0x1>
 830:	bc cf       	rjmp	.-136    	; 0x7aa <free+0x42>
 832:	c2 83       	std	Z+2, r28	; 0x02
 834:	d3 83       	std	Z+3, r29	; 0x03
 836:	40 81       	ld	r20, Z
 838:	51 81       	ldd	r21, Z+1	; 0x01
 83a:	84 0f       	add	r24, r20
 83c:	95 1f       	adc	r25, r21
 83e:	c8 17       	cp	r28, r24
 840:	d9 07       	cpc	r29, r25
 842:	61 f4       	brne	.+24     	; 0x85c <free+0xf4>
 844:	4e 5f       	subi	r20, 0xFE	; 254
 846:	5f 4f       	sbci	r21, 0xFF	; 255
 848:	88 81       	ld	r24, Y
 84a:	99 81       	ldd	r25, Y+1	; 0x01
 84c:	48 0f       	add	r20, r24
 84e:	59 1f       	adc	r21, r25
 850:	40 83       	st	Z, r20
 852:	51 83       	std	Z+1, r21	; 0x01
 854:	8a 81       	ldd	r24, Y+2	; 0x02
 856:	9b 81       	ldd	r25, Y+3	; 0x03
 858:	82 83       	std	Z+2, r24	; 0x02
 85a:	93 83       	std	Z+3, r25	; 0x03
 85c:	21 15       	cp	r18, r1
 85e:	31 05       	cpc	r19, r1
 860:	09 f0       	breq	.+2      	; 0x864 <free+0xfc>
 862:	b0 cf       	rjmp	.-160    	; 0x7c4 <free+0x5c>
 864:	e0 93 3e 3f 	sts	0x3F3E, r30	; 0x803f3e <__flp>
 868:	f0 93 3f 3f 	sts	0x3F3F, r31	; 0x803f3f <__flp+0x1>
 86c:	9e cf       	rjmp	.-196    	; 0x7aa <free+0x42>
 86e:	fd 01       	movw	r30, r26
 870:	dc 01       	movw	r26, r24
 872:	c0 cf       	rjmp	.-128    	; 0x7f4 <free+0x8c>
 874:	12 82       	std	Z+2, r1	; 0x02
 876:	13 82       	std	Z+3, r1	; 0x03
 878:	d7 cf       	rjmp	.-82     	; 0x828 <free+0xc0>

0000087a <memset>:
memset():
 87a:	dc 01       	movw	r26, r24
 87c:	01 c0       	rjmp	.+2      	; 0x880 <memset+0x6>
 87e:	6d 93       	st	X+, r22
 880:	41 50       	subi	r20, 0x01	; 1
 882:	50 40       	sbci	r21, 0x00	; 0
 884:	e0 f7       	brcc	.-8      	; 0x87e <memset+0x4>
 886:	08 95       	ret

00000888 <__do_global_dtors>:
__do_global_dtors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
 888:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
 88a:	cb e1       	ldi	r28, 0x1B	; 27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
 88c:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
 88e:	03 c0       	rjmp	.+6      	; 0x896 <__do_global_dtors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
 890:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
 892:	bc de       	rcall	.-648    	; 0x60c <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
 894:	21 96       	adiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
 896:	cc 31       	cpi	r28, 0x1C	; 28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
 898:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
 89a:	d1 f7       	brne	.-12     	; 0x890 <__do_global_dtors+0x8>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 89c:	f8 94       	cli

0000089e <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 89e:	ff cf       	rjmp	.-2      	; 0x89e <__stop_program>
